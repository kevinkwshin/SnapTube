import streamlit as st
import requests
import google.generativeai as genai
import re
from urllib.parse import urlparse, parse_qs
import json
import xml.etree.ElementTree as ET
import html
import sys
import subprocess

# youtube-transcript-api ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏûêÎèô ÏÑ§Ïπò Î∞è import ÏãúÎèÑ
def install_and_import_youtube_transcript():
    """youtube-transcript-api ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏûêÎèôÏúºÎ°ú ÏÑ§ÏπòÌïòÍ≥† import"""
    try:
        from youtube_transcript_api import YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound, NoTranscriptAvailable
        return YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound, NoTranscriptAvailable, True
    except ImportError:
        st.warning("üì¶ youtube-transcript-api ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÏûêÎèô ÏÑ§ÏπòÎ•º ÏãúÎèÑÌï©ÎãàÎã§...")
        
        try:
            # ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏûêÎèô ÏÑ§Ïπò ÏãúÎèÑ
            subprocess.check_call([sys.executable, "-m", "pip", "install", "youtube-transcript-api"])
            st.success("‚úÖ youtube-transcript-api ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÑ§ÏπòÎêòÏóàÏäµÎãàÎã§!")
            
            # Ïû¨ÏãúÎèÑ
            from youtube_transcript_api import YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound, NoTranscriptAvailable
            return YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound, NoTranscriptAvailable, True
            
        except Exception as install_error:
            st.error(f"‚ùå ÏûêÎèô ÏÑ§Ïπò Ïã§Ìå®: {install_error}")
            st.info("üí° ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏóÜÏù¥ÎèÑ ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë Î∞©ÏãùÏúºÎ°ú ÏûêÎßâ Ï∂îÏ∂úÏùÑ ÏãúÎèÑÌï©ÎãàÎã§.")
            return None, None, None, None, False

# ÎùºÏù¥Î∏åÎü¨Î¶¨ Î°úÎî© ÏãúÎèÑ
YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound, NoTranscriptAvailable, HAS_YOUTUBE_API = install_and_import_youtube_transcript()

# --- ÎπÑÎîîÏò§ ID Ï∂îÏ∂ú ---
def extract_video_id(url):
    """YouTube URLÏóêÏÑú ÎπÑÎîîÏò§ ID Ï∂îÏ∂ú"""
    if not url:
        return None
    url = url.strip()
    if "youtube.com/watch" in url:
        try:
            parsed_url = urlparse(url)
            return parse_qs(parsed_url.query)['v'][0]
        except (KeyError, IndexError):
            return None
    elif "youtu.be/" in url:
        try:
            return url.split("youtu.be/")[1].split("?")[0]
        except IndexError:
            return None
    elif "youtube.com/embed/" in url:
        try:
            return url.split("embed/")[1].split("?")[0]
        except IndexError:
            return None
    elif re.fullmatch(r"^[a-zA-Z0-9_-]{11}$", url):
        return url
    else:
        return None

# --- ÏûêÎßâ Ï∂îÏ∂ú Î°úÏßÅ (youtube-transcript-api ÏÇ¨Ïö© ÏµúÏö∞ÏÑ†, ÏàòÏ†ïÎêú Ïö∞ÏÑ†ÏàúÏúÑ) ---
def get_transcript_from_youtube_api(video_id):
    """youtube-transcript-api ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÏûêÎßâ Í∞ÄÏ†∏Ïò§Í∏∞ (ÏàòÏ†ïÎêú Ïö∞ÏÑ†ÏàúÏúÑ)"""
    if not HAS_YOUTUBE_API:
        st.info("‚ÑπÔ∏è YouTube API ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏñ¥ Í±¥ÎÑàÎúÅÎãàÎã§.")
        return None, "ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏóÜÏùå"
    
    try:
        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)
        
        priority_langs = ['ko', 'en']
        
        # 1. ÏàòÎèô ÏÉùÏÑ± ÏûêÎßâ ÌÉêÏÉâ
        try:
            transcript = transcript_list.find_manually_created_transcript(['ko'])
            fetched_transcript = transcript.fetch()
            st.caption("YouTube API: 'ko' ÏàòÎèô ÏÉùÏÑ± ÏûêÎßâ Î∞úÍ≤¨.")
            return ' '.join([item['text'] for item in fetched_transcript]), "YouTube API (ko, ÏàòÎèô)"
        except NoTranscriptFound: pass
            
        try:
            transcript = transcript_list.find_manually_created_transcript(['en'])
            fetched_transcript = transcript.fetch()
            st.caption("YouTube API: 'en' ÏàòÎèô ÏÉùÏÑ± ÏûêÎßâ Î∞úÍ≤¨.")
            return ' '.join([item['text'] for item in fetched_transcript]), "YouTube API (en, ÏàòÎèô)"
        except NoTranscriptFound: pass

        for t in transcript_list:
            if not t.is_generated and t.language_code not in priority_langs:
                try:
                    fetched_transcript = t.fetch()
                    st.caption(f"YouTube API: '{t.language_code}' ÏàòÎèô ÏÉùÏÑ± ÏûêÎßâ Î∞úÍ≤¨.")
                    return ' '.join([item['text'] for item in fetched_transcript]), f"YouTube API ({t.language_code}, ÏàòÎèô)"
                except Exception: continue

        # 2. ÏûêÎèô ÏÉùÏÑ± ÏûêÎßâ ÌÉêÏÉâ
        try:
            transcript = transcript_list.find_generated_transcript(['ko'])
            fetched_transcript = transcript.fetch()
            st.caption("YouTube API: 'ko' ÏûêÎèô ÏÉùÏÑ± ÏûêÎßâ Î∞úÍ≤¨.")
            return ' '.join([item['text'] for item in fetched_transcript]), "YouTube API (ko, ÏûêÎèô)"
        except NoTranscriptFound: pass

        try:
            transcript = transcript_list.find_generated_transcript(['en'])
            fetched_transcript = transcript.fetch()
            st.caption("YouTube API: 'en' ÏûêÎèô ÏÉùÏÑ± ÏûêÎßâ Î∞úÍ≤¨.")
            return ' '.join([item['text'] for item in fetched_transcript]), "YouTube API (en, ÏûêÎèô)"
        except NoTranscriptFound: pass
            
        for t in transcript_list:
            if t.is_generated and t.language_code not in priority_langs:
                try:
                    fetched_transcript = t.fetch()
                    st.caption(f"YouTube API: '{t.language_code}' ÏûêÎèô ÏÉùÏÑ± ÏûêÎßâ Î∞úÍ≤¨.")
                    return ' '.join([item['text'] for item in fetched_transcript]), f"YouTube API ({t.language_code}, ÏûêÎèô)"
                except Exception: continue

        st.warning("ÏûêÎßâ Ï∂îÏ∂ú Ïã§Ìå® (YouTube API): Ïö∞ÏÑ†ÏàúÏúÑÏóê ÎßûÎäî ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏûêÎßâÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.")
        return None, "ÏûêÎßâ ÏóÜÏùå (API ÏãúÎèÑ ÌõÑ)"

    except TranscriptsDisabled:
        st.warning(f"ÏûêÎßâ Ï∂îÏ∂ú Ïã§Ìå® (YouTube API): [{video_id}] ÎπÑÎîîÏò§Ïóê ÎåÄÌï¥ ÏûêÎßâÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.")
        return None, "ÏûêÎßâ ÎπÑÌôúÏÑ±Ìôî"
    except NoTranscriptAvailable:
        st.warning(f"ÏûêÎßâ Ï∂îÏ∂ú Ïã§Ìå® (YouTube API): [{video_id}] ÎπÑÎîîÏò§Ïóê ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏûêÎßâ Î™©Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.")
        return None, "ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏûêÎßâ Î™©Î°ù ÏóÜÏùå"
    except Exception as e:
        st.error(f"ÏûêÎßâ Ï∂îÏ∂ú Ï§ë Ïò§Î•ò (YouTube API): {e}")
        return None, "API Ïò§Î•ò"


# --- YouTube ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë (Ïã†Î¢∞ÎèÑ ÎÇÆÏùå, ÏàòÏ†ïÎêú Ïö∞ÏÑ†ÏàúÏúÑ Î∞òÏòÅ ÏãúÎèÑ) ---
def get_transcript_youtube_direct(video_id):
    """YouTubeÏóêÏÑú ÏßÅÏ†ë ÏûêÎßâ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (Ïä§ÌÅ¨ÎûòÌïë, Ïã†Î¢∞ÎèÑ ÎÇÆÏùå)"""
    progress_placeholder = st.empty()
    log_messages = []
    priority_langs = ['ko', 'en']

    try:
        progress_placeholder.info(f"üîÑ YouTube ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë ÏãúÎèÑ (Ïö∞ÏÑ†ÏàúÏúÑ: ÏàòÎèô > ÏûêÎèô, ko > en > Í∏∞ÌÉÄ)...")
        
        accept_lang_header_parts = []
        for i, lang_code in enumerate(priority_langs):
            q = 0.9 - i * 0.1
            accept_lang_header_parts.append(f"{lang_code}-{lang_code.upper()};q={q}")
            accept_lang_header_parts.append(f"{lang_code};q={q-0.05}")
        accept_lang_header_parts.append("en-US;q=0.5,en;q=0.4")
        accept_lang_header = ','.join(accept_lang_header_parts)

        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36',
            'Accept-Language': accept_lang_header,
        }
        url = f"https://www.youtube.com/watch?v={video_id}&hl={priority_langs[0]}"
        response = requests.get(url, headers=headers, timeout=20)
        
        if response.status_code == 200:
            page_content = response.text
            caption_url = None
            source_type = None
            all_found_tracks = []

            match_player_captions = re.search(r'"playerCaptionsTracklistRenderer":\s*(\{.*?\})', page_content)
            if match_player_captions:
                source_type = 'playerCaptions'
                try:
                    captions_json_str = match_player_captions.group(1).encode('utf-8').decode('unicode_escape')
                    captions_data = json.loads(captions_json_str)
                    if "captionTracks" in captions_data:
                        all_found_tracks.extend(captions_data["captionTracks"])
                except Exception as e:
                    log_messages.append(f"ERROR ({source_type}): Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò - {e}")

            caption_tracks_match = re.search(r'"captionTracks":(\[.*?\])', page_content)
            if caption_tracks_match:
                source_type = source_type or 'legacyCaptionTracks'
                try:
                    caption_tracks_json_str = caption_tracks_match.group(1).encode('utf-8').decode('unicode_escape')
                    existing_baseUrls = {track.get("baseUrl") for track in all_found_tracks}
                    new_tracks = json.loads(caption_tracks_json_str)
                    for nt in new_tracks:
                        if nt.get("baseUrl") not in existing_baseUrls:
                            all_found_tracks.append(nt)
                except Exception as e:
                    log_messages.append(f"ERROR (legacyCaptionTracks): Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò - {e}")
            
            log_messages.append(f"DEBUG: Ï¥ù {len(all_found_tracks)}Í∞úÏùò ÏûêÎßâ Ìä∏Îûô Ï†ïÎ≥¥ Î∞úÍ≤¨ (Ïä§ÌÅ¨ÎûòÌïë)")
            selected_track_info = None

            for lang in priority_langs:
                for track in all_found_tracks:
                    if track.get("languageCode") == lang and "baseUrl" in track and track.get("kind") != "asr" and not track.get("isTranslatable"):
                        selected_track_info = (track["baseUrl"], f"{lang}, ÏàòÎèô")
                        break
                if selected_track_info: break
            
            if not selected_track_info:
                for track in all_found_tracks:
                    if "baseUrl" in track and track.get("kind") != "asr" and not track.get("isTranslatable") and track.get("languageCode") not in priority_langs:
                        selected_track_info = (track["baseUrl"], f"{track.get('languageCode', 'N/A')}, ÏàòÎèô")
                        break
            
            if not selected_track_info:
                for lang in priority_langs:
                    for track in all_found_tracks:
                        if track.get("languageCode") == lang and "baseUrl" in track and (track.get("kind") == "asr" or track.get("isTranslatable")):
                            selected_track_info = (track["baseUrl"], f"{lang}, ÏûêÎèô")
                            break
                    if selected_track_info: break

            if not selected_track_info:
                for track in all_found_tracks:
                    if "baseUrl" in track and (track.get("kind") == "asr" or track.get("isTranslatable")) and track.get("languageCode") not in priority_langs:
                        selected_track_info = (track["baseUrl"], f"{track.get('languageCode', 'N/A')}, ÏûêÎèô")
                        break
            
            if selected_track_info:
                caption_url, track_desc = selected_track_info
                log_messages.append(f"INFO: ÏÑ†ÌÉùÎêú ÏûêÎßâ Ìä∏Îûô ({track_desc}) URL: {caption_url}")
                
                if 'format=' not in caption_url: # ÏòàÏ†ÑÏóêÎäî fmt ÏòÄÏúºÎÇò, ÏµúÍ∑ºÏóêÎäî formatÏù¥ Îçî ÎßéÏù¥ Î≥¥ÏûÑ
                    caption_url += "&format=srv3" # srv3 (XML), ttml (Timed Text XML), vtt (WebVTT)

                caption_response = requests.get(caption_url, headers=headers, timeout=15)
                if caption_response.status_code == 200:
                    try:
                        transcript_text = caption_response.text
                        root = ET.fromstring(transcript_text)
                        transcript_parts = []
                        for elem_tag in ['text', 'p', 's']: 
                            for elem in root.findall(f'.//{elem_tag}'):
                                if elem.text:
                                    transcript_parts.append(elem.text.strip())
                        
                        if transcript_parts:
                            full_transcript = ' '.join(transcript_parts)
                            full_transcript = html.unescape(full_transcript)
                            full_transcript = re.sub(r'\s+', ' ', full_transcript).strip()
                            
                            if len(full_transcript) > 30:
                                progress_placeholder.success(f"‚úÖ YouTube ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë ÏÑ±Í≥µ ({track_desc})!")
                                return full_transcript
                            else:
                                log_messages.append(f"WARNING: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - ÏûêÎßâ ÎÇ¥Ïö©Ïù¥ ÎÑàÎ¨¥ ÏßßÏùå ({len(full_transcript)}Ïûê)")
                        else:
                            log_messages.append("WARNING: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - XMLÏóêÏÑú ÌÖçÏä§Ìä∏ ÏöîÏÜå Ï∞æÍ∏∞ Ïã§Ìå®")
                    except ET.ParseError:
                        log_messages.append("ERROR: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - ÏûêÎßâ XML ÌååÏã± Ïã§Ìå®. ÏõêÎ≥∏:\n" + caption_response.text[:200])
                    except Exception as parse_e:
                        log_messages.append(f"ERROR: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - ÏûêÎßâ ÌååÏã± Ï§ë ÏòàÏô∏: {parse_e}")
                else:
                    log_messages.append(f"ERROR: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - ÏûêÎßâ URL ({caption_url}) Ï†ëÍ∑º Ïã§Ìå® (Status: {caption_response.status_code})")
            else:
                log_messages.append("WARNING: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - Ïö∞ÏÑ†ÏàúÏúÑÏóê ÎßûÎäî Ïú†Ìö®Ìïú ÏûêÎßâ URLÏùÑ ÏµúÏ¢ÖÏ†ÅÏúºÎ°ú Ï∞æÏßÄ Î™ªÌï®")
        else:
            log_messages.append(f"ERROR: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - YouTube ÌéòÏù¥ÏßÄ Ï†ëÍ∑º Ïã§Ìå® (Status: {response.status_code})")

    except requests.exceptions.Timeout:
        log_messages.append(f"ERROR: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - ÏöîÏ≤≠ ÏãúÍ∞Ñ Ï¥àÍ≥º")
    except requests.exceptions.RequestException as e:
        log_messages.append(f"ERROR: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò: {str(e)}")
    except Exception as e:
        log_messages.append(f"ERROR: ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë - ÏùºÎ∞ò Ïò§Î•ò: {str(e)}")
    
    progress_placeholder.empty()
    if log_messages:
        with st.expander("üîç ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë ÏÉÅÏÑ∏ Î°úÍ∑∏ Î≥¥Í∏∞ (Ïã†Î¢∞ÎèÑ ÎÇÆÏùå)", expanded=False):
            for msg in log_messages:
                st.write(msg)
    return None

# --- Î™®Îì† Î∞©Î≤ï ÌÜµÌï© ---
def get_transcript(video_id):
    """Î™®Îì† Î∞©Î≤ïÏùÑ ÏãúÎèÑÌï¥ÏÑú ÏûêÎßâ Í∞ÄÏ†∏Ïò§Í∏∞"""
    
    if HAS_YOUTUBE_API:
        st.info("üîÑ Î∞©Î≤ï 1: YouTube API (ÎùºÏù¥Î∏åÎü¨Î¶¨) ÏãúÎèÑ Ï§ë...")
        transcript_text, method = get_transcript_from_youtube_api(video_id)
        if transcript_text:
            st.success(f"‚úÖ {method} ÌÜµÌï¥ ÏûêÎßâ ÌôïÎ≥¥!")
            return transcript_text, method, len(transcript_text)
        st.warning("‚ö†Ô∏è YouTube API ÎùºÏù¥Î∏åÎü¨Î¶¨ Ïã§Ìå®. ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë ÏãúÎèÑ Ï§ë (Ïã†Î¢∞ÎèÑ ÎÇÆÏùå)...")
    else:
        st.info("‚ÑπÔ∏è YouTube API ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë Î∞©ÏãùÏùÑ ÏãúÎèÑÌï©ÎãàÎã§.")
    
    transcript_text = get_transcript_youtube_direct(video_id)
    if transcript_text:
        st.success("‚úÖ ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë ÌÜµÌï¥ ÏûêÎßâ ÌôïÎ≥¥!")
        return transcript_text, "ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë", len(transcript_text)
    
    return None, None, None

# --- Gemini ÏöîÏïΩ ---
def summarize_text(text, api_key):
    """GeminiÎ°ú ÏöîÏïΩ ÏÉùÏÑ± - Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ"""
    try:
        genai.configure(api_key=api_key)
        
        max_chars = 30000 
        if len(text) > max_chars:
            text_to_summarize = text[:max_chars]
            st.caption(f"ÏûêÎßâÏù¥ ÎÑàÎ¨¥ Í∏∏Ïñ¥ ÏïûÎ∂ÄÎ∂Ñ {max_chars}ÏûêÎßå ÏöîÏïΩÏóê ÏÇ¨Ïö©Ìï©ÎãàÎã§.")
        else:
            text_to_summarize = text
        
        models_to_try = [
            'gemini-1.5-flash-latest', 
            'gemini-1.5-pro-latest',
            'gemini-pro' 
        ] 
        
        st.info(f"ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Gemini Î™®Îç∏ ÏàúÏÑú: {', '.join(models_to_try)}")

        for model_name in models_to_try:
            st.info(f"üîÑ Gemini Î™®Îç∏ '{model_name}'ÏúºÎ°ú ÏöîÏïΩ ÏãúÎèÑ Ï§ë...")
            try:
                model = genai.GenerativeModel(
                    model_name,
                    generation_config=genai.types.GenerationConfig(
                        temperature=0.2,
                        top_p=0.95,    
                        top_k=64,      
                        max_output_tokens=4096,
                    ),
                    safety_settings=[ 
                        {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
                        {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
                        {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
                        {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
                    ]
                )
                
                prompt = f"""Ï†úÍ≥µÎêú YouTube ÏòÅÏÉÅ ÏûêÎßâÏùÑ Î∞îÌÉïÏúºÎ°ú, Îã§Ïùå ÌòïÏãùÏóê ÎßûÏ∂∞ ÌïúÍµ≠Ïñ¥Î°ú Î™ÖÌôïÌïòÍ≥† Í∞ÑÍ≤∞ÌïòÍ≤å ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî.

**ÏòÅÏÉÅ ÏûêÎßâ:**
---
{text_to_summarize}
---

**ÏöîÏïΩ ÌòïÏãù:**

## üìå ÏòÅÏÉÅÏùò ÌïµÏã¨ Ï£ºÏ†ú
Ïù¥ ÏòÅÏÉÅÏù¥ Îã§Î£®Îäî Ï£ºÏöî Ï£ºÏ†úÎÇò Î©îÏãúÏßÄÎ•º ÌïúÎëê Î¨∏Ïû•ÏúºÎ°ú Î™ÖÎ£åÌïòÍ≤å ÏÑ§Î™ÖÌï¥Ï£ºÏÑ∏Ïöî.

## üîë Ï£ºÏöî ÎÇ¥Ïö© Ìè¨Ïù∏Ìä∏ (3-5Í∞ú)
ÏòÅÏÉÅÏóêÏÑú Í∞ÄÏû• Ï§ëÏöîÌïòÎã§Í≥† ÏÉùÍ∞ÅÎêòÎäî ÌïµÏã¨ ÎÇ¥Ïö©Îì§ÏùÑ Î≤àÌò∏ Î™©Î°ùÏúºÎ°ú 3Í∞úÏóêÏÑú 5Í∞ú ÏÇ¨Ïù¥Î°ú Ï†ïÎ¶¨Ìï¥Ï£ºÏÑ∏Ïöî. Í∞Å Ìï≠Î™©ÏùÄ Íµ¨Ï≤¥Ï†ÅÏù¥Î©¥ÏÑúÎèÑ Ïù¥Ìï¥ÌïòÍ∏∞ Ïâ¨ÏõåÏïº Ìï©ÎãàÎã§.
1.  [Ï≤´ Î≤àÏß∏ ÌïµÏã¨ ÎÇ¥Ïö©]
2.  [Îëê Î≤àÏß∏ ÌïµÏã¨ ÎÇ¥Ïö©]
3.  [ÏÑ∏ Î≤àÏß∏ ÌïµÏã¨ ÎÇ¥Ïö©]
    (ÌïÑÏöîÏóê Îî∞Îùº 4Î≤àÏß∏, 5Î≤àÏß∏ ÎÇ¥Ïö© Ï∂îÍ∞Ä)

## üí° Í≤∞Î°† Î∞è ÏãúÏÇ¨Ï†ê
ÏòÅÏÉÅÏùò Í≤∞Î°†ÏùÄ Î¨¥ÏóáÏù¥Î©∞, ÏãúÏ≤≠ÏûêÍ∞Ä ÏñªÏùÑ Ïàò ÏûàÎäî ÍµêÌõàÏù¥ÎÇò ÏÉùÍ∞ÅÌï¥Î≥º Ï†êÏùÄ Î¨¥ÏóáÏù∏ÏßÄ Í∞ÑÎûµÌûà Í∏∞Ïà†Ìï¥Ï£ºÏÑ∏Ïöî. ÎßåÏïΩ ÏòÅÏÉÅÏù¥ ÌäπÏ†ï ÌñâÎèôÏùÑ Ï¥âÍµ¨ÌïúÎã§Î©¥ Í∑∏Í≤ÉÎèÑ Ïñ∏Í∏âÌï¥Ï£ºÏÑ∏Ïöî.

**Ï£ºÏùòÏÇ¨Ìï≠:**
- Î∞òÎìúÏãú ÌïúÍµ≠Ïñ¥Î°ú ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.
- ÏõêÎ≥∏ ÏûêÎßâÏùò ÎÇ¥Ïö©ÏùÑ Ï∂©Ïã§Ìûà Î∞òÏòÅÌïòÎêò, Î∂àÌïÑÏöîÌïú Î∞òÎ≥µÏù¥ÎÇò ÏÇ¨Í≤¨ÏùÄ Î∞∞Ï†úÌï¥Ï£ºÏÑ∏Ïöî.
- Ï†ÑÎ¨∏ Ïö©Ïñ¥Îäî ÏâΩÍ≤å ÌíÄÏñ¥ÏÑú ÏÑ§Î™ÖÌïòÍ±∞ÎÇò, ÌïÑÏöîÌïú Í≤ΩÏö∞ Í∞ÑÎûµÌûà Î∂ÄÏó∞Ìï¥Ï£ºÏÑ∏Ïöî.
"""
                
                response = model.generate_content(prompt)
                
                if response.parts:
                    return response.text
                elif response.prompt_feedback and response.prompt_feedback.block_reason:
                    reason = response.prompt_feedback.block_reason
                    st.error(f"ÏΩòÌÖêÏ∏† ÏïàÏ†Ñ Î¨∏Ï†úÎ°ú Gemini ÏùëÎãµÏù¥ Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§ ({model_name}): {reason}")
                    if model_name == models_to_try[-1]:
                        return f"‚ùå ÏöîÏïΩ ÏÉùÏÑ± Ïã§Ìå®: Gemini APIÍ∞Ä ÏΩòÌÖêÏ∏† ÏïàÏ†Ñ Î¨∏Ï†úÎ°ú ÏùëÎãµÏùÑ Ï∞®Îã®ÌñàÏäµÎãàÎã§ ({reason}). Îã§Î•∏ ÎπÑÎîîÏò§Î•º ÏãúÎèÑÌï¥Î≥¥Í±∞ÎÇò, ÏûêÎßâ ÎÇ¥Ïö©ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî."
                    st.warning("Îã§Î•∏ Î™®Îç∏Î°ú Ïû¨ÏãúÎèÑÌï©ÎãàÎã§...")
                    continue
                else:
                    st.warning(f"'{model_name}' Î™®Îç∏ÏóêÏÑú ÏöîÏïΩ ÎÇ¥Ïö©ÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§ (ÏùëÎãµ ÎπÑÏñ¥ÏûàÏùå). Îã§Ïùå Î™®Îç∏ÏùÑ ÏãúÎèÑÌï©ÎãàÎã§.")
                    continue 
                
            except Exception as model_error:
                error_msg_lower = str(model_error).lower()
                st.warning(f"'{model_name}' Î™®Îç∏ ÏöîÏïΩ Ï§ë Ïò§Î•ò Î∞úÏÉù: {str(model_error)[:150]}...")
                if any(keyword in error_msg_lower for keyword in ['api key not valid', 'permission denied', 'authentication']):
                    st.error("‚ùå Gemini API ÌÇ§Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÍ±∞ÎÇò Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. ÌÇ§Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.")
                    return "‚ùå API ÌÇ§ Ïò§Î•ò: Gemini API ÌÇ§Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÍ±∞ÎÇò Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§."
                elif 'quota' in error_msg_lower or 'limit' in error_msg_lower or 'resource_exhausted' in error_msg_lower:
                    st.error(f"API Ìï†ÎãπÎüâÏùÑ Ï¥àÍ≥ºÌñàÍ±∞ÎÇò Î¶¨ÏÜåÏä§Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§ ({model_name}). Îã§Î•∏ ÌÇ§Î•º ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.")
                    if model_name == models_to_try[-1]:
                        return "‚ùå API Ìï†ÎãπÎüâ Ï¥àÍ≥º ÎòêÎäî Î¶¨ÏÜåÏä§ Î∂ÄÏ°±: ÏÇ¨Ïö©ÎüâÏù¥ ÌïúÎèÑÎ•º Ï¥àÍ≥ºÌñàÍ±∞ÎÇò ÏÑúÎ≤Ñ Î¶¨ÏÜåÏä§Í∞Ä ÏùºÏãúÏ†ÅÏúºÎ°ú Î∂ÄÏ°±Ìï©ÎãàÎã§."
                    continue
                elif any(keyword in error_msg_lower for keyword in ['model_not_found', 'not found', '404', 'unavailable']):
                    st.warning(f"'{model_name}' Î™®Îç∏ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÍ±∞ÎÇò ÌòÑÏû¨ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.")
                if model_name == models_to_try[-1]:
                    st.error(f"Î™®Îì† Î™®Îç∏ ÏãúÎèÑ ÌõÑÏóêÎèÑ '{model_name}'ÏóêÏÑú ÏöîÏïΩ ÏÉùÏÑ± Ïã§Ìå®.")
                    break 
                st.warning("Îã§Î•∏ Î™®Îç∏Î°ú Ïû¨ÏãúÎèÑÌï©ÎãàÎã§...")
                continue
        
        st.error("Î™®Îì† Gemini Î™®Îç∏ÏóêÏÑú ÏöîÏïΩ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.")
        return "‚ùå ÏöîÏïΩ ÏÉùÏÑ± Ïã§Ìå®: Î™®Îì† Gemini Î™®Îç∏ÏóêÏÑú ÏöîÏïΩÏùÑ Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§. API ÌÇ§, ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÉÅÌÉú, Ìï†ÎãπÎüâÏùÑ ÌôïÏù∏ÌïòÍ±∞ÎÇò Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî."
        
    except genai.types.generation_types.BlockedPromptException as bpe:
        st.error(f"ÏΩòÌÖêÏ∏† ÏïàÏ†Ñ Î¨∏Ï†úÎ°ú Gemini ÏöîÏ≤≠ ÏûêÏ≤¥Í∞Ä Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§: {bpe}")
        return f"‚ùå ÏöîÏïΩ ÏÉùÏÑ± Ïã§Ìå®: Gemini APIÍ∞Ä ÏΩòÌÖêÏ∏† ÏïàÏ†Ñ Î¨∏Ï†úÎ°ú Ï¥àÍ∏∞ ÏöîÏ≤≠ÏùÑ Ï∞®Îã®ÌñàÏäµÎãàÎã§. Îã§Î•∏ ÎπÑÎîîÏò§Î•º ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî."
    except Exception as e:
        error_msg = str(e).lower()
        if 'api_key' in error_msg:
            st.error("‚ùå API ÌÇ§ Ïò§Î•ò: Gemini API ÌÇ§ ÏÑ§Ï†ï Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌÇ§Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.")
            return "‚ùå API ÌÇ§ Ïò§Î•ò: Gemini API ÌÇ§Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÍ±∞ÎÇò ÏÑ§Ï†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§."
        else:
            st.error(f"‚ùå ÏöîÏïΩ ÏÉùÏÑ± Ï§ë Ïïå Ïàò ÏóÜÎäî Ï†ÑÏó≠ Ïò§Î•ò Î∞úÏÉù: {e}")
            return f"‚ùå ÏöîÏïΩ ÏÉùÏÑ± Ïã§Ìå® (Ï†ÑÏó≠): {e}"

# --- Streamlit UI ---
def main():
    st.set_page_config(
        page_title="YouTube ÏûêÎßâ ÏöîÏïΩÍ∏∞ (v2.2)",
        page_icon="üì∫‚ú®",
        layout="wide"
    )
    
    st.title("üì∫ YouTube ÏûêÎßâ ÏöîÏïΩÍ∏∞ ‚ú®")
    st.markdown("YouTube ÎπÑÎîîÏò§Ïùò ÏûêÎßâÏùÑ Ï∂îÏ∂úÌïòÍ≥† **Gemini AI** (ÏµúÎåÄ `gemini-1.5-flash-latest`)Î°ú ÏöîÏïΩÌï©ÎãàÎã§.")
    st.caption("ÏûêÎßâ ÏÑ†ÌÉù Ïö∞ÏÑ†ÏàúÏúÑ: (ÏàòÎèô ÏûêÎßâ: ko > en > Í∏∞ÌÉÄ) > (ÏûêÎèô ÏûêÎßâ: ko > en > Í∏∞ÌÉÄ)")
    
    # ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÉÅÌÉú ÌëúÏãú
    if HAS_YOUTUBE_API:
        st.success("‚úÖ youtube-transcript-api ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÇ¨Ïö© Í∞ÄÎä•", icon="üì¶")
    else:
        st.warning("‚ö†Ô∏è youtube-transcript-api ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏóÜÏùå - ÏßÅÏ†ë Ïä§ÌÅ¨ÎûòÌïë Î∞©Ïãù ÏÇ¨Ïö©", icon="üì¶")
        st.info("üí° Îçî ÏïàÏ†ïÏ†ÅÏù∏ ÏûêÎßâ Ï∂îÏ∂úÏùÑ ÏúÑÌï¥ Îã§Ïùå Î™ÖÎ†πÏñ¥Î°ú ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏÑ§ÏπòÌïòÎäî Í≤ÉÏùÑ Í∂åÏû•Ìï©ÎãàÎã§:")
        st.code("pip install youtube-transcript-api")
    
    with st.sidebar:
        st.header("‚öôÔ∏è ÏÑ§Ï†ï")
        gemini_api_key = st.text_input(
            "üîë Gemini API Key",
            type="password",
            help="Google AI Studio (Makersuite)ÏóêÏÑú Î∞úÍ∏âÎ∞õÏùÄ API ÌÇ§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî."
        )
        if gemini_api_key:
            st.success("API ÌÇ§Í∞Ä ÏûÖÎ†•ÎêòÏóàÏäµÎãàÎã§.", icon="‚úÖ")
        else:
            st.warning("API ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", icon="‚ö†Ô∏è")
        
        st.link_button("API ÌÇ§ Î∞úÍ∏âÎ∞õÍ∏∞ (Google AI Studio)", "https://makersuite.google.com/app/apikey")
        
        # ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÉÅÌÉú Ï†ïÎ≥¥
        st.divider()
        st.header("üì¶ ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÉÅÌÉú")
        if HAS_YOUTUBE_API:
            st.success("youtube-transcript-api: ‚úÖ ÏÇ¨Ïö© Í∞ÄÎä•")
        else:
            st.error("youtube-transcript-api: ‚ùå ÏóÜÏùå")
            if st.button("üîÑ ÎùºÏù¥Î∏åÎü¨Î¶¨ Ïû¨ÏãúÎèÑ"):
                st.rerun()
        
    video_input = st.text_input(
        "üé• YouTube URL ÎòêÎäî ÎπÑÎîîÏò§ ID",
        placeholder="Ïòà: https://www.youtube.com/watch?v=dQw4w9WgXcQ ÎòêÎäî dQw4w9WgXcQ",
        help="YouTube ÎπÑÎîîÏò§Ïùò Ï†ÑÏ≤¥ URL ÎòêÎäî 11ÏûêÎ¶¨ ÎπÑÎîîÏò§ IDÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî."
    )
    
    if st.button("üöÄ ÏûêÎßâ Ï∂îÏ∂ú Î∞è AI ÏöîÏïΩ", type="primary", use_container_width=True, disabled=(not gemini_api_key)):
        if not video_input:
            st.error("‚ùå YouTube URL ÎòêÎäî ÎπÑÎîîÏò§ IDÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!")
            return
        
        video_id = extract_video_id(video_input)
        if not video_id:
            st.error("‚ùå Ïú†Ìö®Ìïú YouTube URL ÎòêÎäî ÎπÑÎîîÏò§ ID ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§. Îã§Ïãú ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.")
            return
            
        st.info(f"üéØ Ï∂îÏ∂úÎêú ÎπÑÎîîÏò§ ID: {video_id}")
        
        transcript_text, method, length = None, None, None
        with st.spinner("üìÑ ÏûêÎßâ Í∞ÄÏ†∏Ïò§Îäî Ï§ë... (ÏµúÎåÄ 30Ï¥à ÏÜåÏöîÎê† Ïàò ÏûàÏùå)"):
            transcript_text, method, length = get_transcript(video_id)
        
        if not transcript_text:
            st.error("‚ùå ÏûêÎßâÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏóàÏäµÎãàÎã§. Îã§ÏùåÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî:")
            with st.expander("ÏûêÎßâ Ï∂îÏ∂ú Ïã§Ìå® Ïãú ÌôïÏù∏ ÏÇ¨Ìï≠", expanded=True):
                st.markdown("""
                - ÎπÑÎîîÏò§Ïóê **ÏûêÎßâÏù¥ Ïã§Ï†úÎ°ú Ï°¥Ïû¨**ÌïòÎäîÏßÄ (ko ÎòêÎäî en Ïö∞ÏÑ†).
                - ÎπÑÎîîÏò§Í∞Ä **Í≥µÍ∞ú ÏÉÅÌÉú**Ïù∏ÏßÄ (ÎπÑÍ≥µÍ∞ú, ÏùºÎ∂Ä Í≥µÍ∞ú, Ïó∞Î†π Ï†úÌïú ÎπÑÎîîÏò§Îäî Ï∂îÏ∂úÏù¥ Ïñ¥Î†§Ïö∏ Ïàò ÏûàÏùå).
                - Îß§Ïö∞ ÏßßÍ±∞ÎÇò ÎÇ¥Ïö©Ïù¥ ÏóÜÎäî ÎπÑÎîîÏò§Îäî ÏïÑÎãåÏßÄ.
                - ÎìúÎ¨ºÍ≤å YouTube ÏûêÏ≤¥Ïùò ÏùºÏãúÏ†ÅÏù∏ Î¨∏Ï†úÏùº ÏàòÎèÑ ÏûàÏäµÎãàÎã§.
                
                **Îã§Î•∏ ÎπÑÎîîÏò§Î°ú ÏãúÎèÑÌï¥Î≥¥Í±∞ÎÇò, Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.**
                """)
            return
        
        st.success(f"‚úÖ ÏûêÎßâ Ï∂îÏ∂ú ÏÑ±Í≥µ! (Î∞©Î≤ï: {method}, Í∏∏Ïù¥: {length:,}Ïûê)")
        
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### üìú ÏõêÎ≥∏ ÏûêÎßâ")
            st.text_area(
                "Ï∂îÏ∂úÎêú ÏûêÎßâ ÎÇ¥Ïö©:",
                transcript_text,
                height=400,
                key="transcript_display"
            )
            st.download_button(
                "üì• ÏûêÎßâ Îã§Ïö¥Î°úÎìú (.txt)",
                transcript_text,
                f"transcript_{video_id}.txt",
                mime="text/plain",
                use_container_width=True
            )
        
        with col2:
            st.markdown("### ü§ñ AI ÏöîÏïΩ (Gemini)")
            with st.spinner("üß† Gemini AIÍ∞Ä ÏöîÏïΩ ÏÉùÏÑ± Ï§ë... (ÏûêÎßâ Í∏∏Ïù¥Ïóê Îî∞Îùº Î™á Ï¥à ~ Î™á Î∂Ñ ÏÜåÏöî)"):
                summary = summarize_text(transcript_text, gemini_api_key)
            
            if "‚ùå" in summary:
                st.error(summary)
            else:
                st.success("‚úÖ AI ÏöîÏïΩ ÏÉùÏÑ± ÏôÑÎ£å!")
                st.markdown(summary)
                st.download_button(
                    "üì• ÏöîÏïΩ Îã§Ïö¥Î°úÎìú (.md)",
                    summary,
                    f"summary_{video_id}.md",
                    mime="text/markdown",
                    use_container_width=True
                )

if __name__ == "__main__":
    main()
